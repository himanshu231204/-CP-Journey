ğŸ“˜ Important STL Containers for Competitive Programming

1ï¸âƒ£ vector
ğŸ”¹ Dynamic array
ğŸ”¹ Fast access via index
ğŸ”¹ Useful for arrays, graphs, dynamic lists
ğŸ”¹ Syntax: vector<int> v;

2ï¸âƒ£ pair
ğŸ”¹ Holds two values together
ğŸ”¹ Useful in sorting with value-index, or edges in graphs
ğŸ”¹ Syntax: pair<int, int> p = {a, b};

3ï¸âƒ£ set
ğŸ”¹ Stores unique sorted elements
ğŸ”¹ Useful for finding/removing duplicates, fast search
ğŸ”¹ O(log n) insertion/deletion
ğŸ”¹ Syntax: set<int> s;

4ï¸âƒ£ multiset
ğŸ”¹ Like set, but allows duplicates
ğŸ”¹ Useful when duplicates matter (e.g., freq of values)
ğŸ”¹ Syntax: multiset<int> ms;

5ï¸âƒ£ unordered_set
ğŸ”¹ Stores unique elements (no order)
ğŸ”¹ Faster average-case O(1) operations
ğŸ”¹ Syntax: unordered_set<int> us;

6ï¸âƒ£ map
ğŸ”¹ Stores key-value pairs in sorted order
ğŸ”¹ Useful for frequency maps, hash tables
ğŸ”¹ Syntax: map<int, int> mp;

7ï¸âƒ£ unordered_map
ğŸ”¹ Like map, but faster (average O(1)) & unordered
ğŸ”¹ Syntax: unordered_map<string, int> ump;

8ï¸âƒ£ stack
ğŸ”¹ LIFO (Last In First Out)
ğŸ”¹ Useful for DFS, expression parsing, bracket matching
ğŸ”¹ Syntax: stack<int> s;

9ï¸âƒ£ queue
ğŸ”¹ FIFO (First In First Out)
ğŸ”¹ Useful for BFS, level-order traversal
ğŸ”¹ Syntax: queue<int> q;

ğŸ”Ÿ deque (Double-ended queue)
ğŸ”¹ Insertion/removal from both ends
ğŸ”¹ Useful for sliding window problems
ğŸ”¹ Syntax: deque<int> dq;

1ï¸âƒ£1ï¸âƒ£ priority_queue
ğŸ”¹ Max heap by default
ğŸ”¹ Useful for Dijkstra, Greedy problems
ğŸ”¹ Syntax:
    - Max heap: priority_queue<int> pq;
    - Min heap: priority_queue<int, vector<int>, greater<int>> pq;

1ï¸âƒ£2ï¸âƒ£ bitset
ğŸ”¹ Space-efficient way to store 0/1 flags
ğŸ”¹ Useful for sieve of Eratosthenes, bitmask DP
ğŸ”¹ Syntax: bitset<10000001> bs;



ğŸ” Extra Useful STL Components (Advanced / Situational)

1ï¸âƒ£ list
ğŸ”¹ Doubly linked list
ğŸ”¹ Useful in rare cases needing fast insertion/deletion from middle
ğŸ”¹ Syntax: list<int> l;

2ï¸âƒ£ array (std::array)
ğŸ”¹ Fixed-size array with STL-like functions
ğŸ”¹ Safer and cleaner than C-style arrays
ğŸ”¹ Syntax: array<int, 100> arr;

3ï¸âƒ£ tuple
ğŸ”¹ Like pair but for 3+ values
ğŸ”¹ Used in graphs, sorting with multiple keys
ğŸ”¹ Syntax: tuple<int, int, int> t;

4ï¸âƒ£ set / map with custom comparator
ğŸ”¹ For sorting in descending/custom logic
ğŸ”¹ Syntax: set<int, greater<int>> s;

5ï¸âƒ£ multimap / unordered_multimap
ğŸ”¹ Like map but allows duplicate keys
ğŸ”¹ Useful for certain greedy or frequency-based problems

6ï¸âƒ£ string (and its methods)
ğŸ”¹ Built-in STL string has powerful functions
ğŸ”¹ Eg: `substr`, `find`, `erase`, `insert`, `reverse`

7ï¸âƒ£ stringstream
ğŸ”¹ Used for parsing input strings
ğŸ”¹ Useful in problems involving parsing numbers/words
ğŸ”¹ Syntax: stringstream ss(str);

8ï¸âƒ£ queue-based variants
ğŸ”¹ priority_queue with custom comparator (for structs, pairs, etc.)
ğŸ”¹ deque for monoqueue tricks

9ï¸âƒ£ STL algorithms (not containers but VERY useful)
ğŸ”¹ `sort(all(v))`, `binary_search()`, `lower_bound()`, `upper_bound()`, `reverse()`, `accumulate()`, `count()`, etc.
